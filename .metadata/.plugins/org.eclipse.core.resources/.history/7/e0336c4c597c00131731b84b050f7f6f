package com.example.myfeatureextraction;

import android.graphics.Color;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.opengl.Matrix;
import android.os.Bundle;
import android.app.Activity;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.TextView;

public class MyFeatureExtraction extends Activity implements SensorEventListener {

	private String TAG;
	private SensorManager mSensorManager;
    private Sensor mSensor;
    private float[] m_vals;
    
    private final int sensorType = Sensor.TYPE_LINEAR_ACCELERATION;
    private int sensorDelay = SensorManager.SENSOR_DELAY_FASTEST;
    
    //displays
    private TextView display;
 	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_my_feature_extraction);
		
		TAG = "MyOrientationTest";
        mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(sensorType);
        
		//displays
		display = (TextView)findViewById(R.id.vals);
		
		//evitar que se apague la pantalla
		getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
		
		m_vals = new float[3];
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.my_feature_extraction, menu);
		return true;
	}
	
	protected void onResume() {
        super.onResume();
        mSensorManager.registerListener(this, mSensor, sensorDelay);
    }

    protected void onPause() {
        super.onPause();
        mSensorManager.unregisterListener(this);
    }

    public void onAccuracyChanged(Sensor sensor, int accuracy) {
    }

    public void onSensorChanged(SensorEvent event) {
    	//Log.d(TAG, "onSensorChanged");
    	if (event.sensor.getType() != sensorType)
            return;
    	
    	// get gravity and linear acceleration
    	float[] gAccel = event.values.clone();
    	gAccel[0] = gAccel[0] / SensorManager.GRAVITY_EARTH;
    	gAccel[1] = gAccel[1] / SensorManager.GRAVITY_EARTH;
    	gAccel[2] = gAccel[2] / SensorManager.GRAVITY_EARTH;

    	float[][] local_grav_linnearAcc;
    	if(lpfUsed == USE_LPF_WIKI)
    		local_grav_linnearAcc = lpfWiki.addSamples(gAccel);
    	else
    		local_grav_linnearAcc = lpfAndDev.addSamples(gAccel);
    	
    	float[] localGravity = local_grav_linnearAcc[0];
    	float[] localLinnearAcc = local_grav_linnearAcc[1];
    	float[] globalLinnearAcc = new float[3];
    	
    	// calculate magDir TODO
    	float[] magDir;
    	float[] x = {1f,0f,0f};
    	float[] y = {0f,1f,0f};
    	float[] z = {0f,0f,1f};
    	float[] cx = cross(localGravity, x);
    	float[] cy = cross(localGravity, y);
    	float[] cz = cross(localGravity, z);
    	
    	double lencx = vecLength(cx);
    	double lency = vecLength(cy);
    	double lencz = vecLength(cz);
    	
    	magDir = cx;
    	double lenmagDir = lencx;
    	if(lency > lenmagDir){
    		magDir = cy;
    		lenmagDir = lency;
    	}
    	if(lencz > lenmagDir){
    		magDir = cz;
    	}
    	
    	// get global coordinates
    	if (SensorManager.getRotationMatrix(m_rotationMatrix, null,
    			localGravity, magDir)) {
			/*
    		SensorManager.getOrientation(m_rotationMatrix, m_vals);
			m_vals[0] = (float) Math.toDegrees(m_vals[0]);
			m_vals[1] = (float) Math.toDegrees(m_vals[1]);
			m_vals[2] = (float) Math.toDegrees(m_vals[2]);
			*/
    		newDataAlarm();
			
    		
    		// get global linear acceleration
    		float[] resp = new float[4];
    		float[] t = {localLinnearAcc[0],localLinnearAcc[1],localLinnearAcc[2],0};
    		float[] m16 = new float[16];
    		m16[0]=m_rotationMatrix[0];
    		m16[1]=m_rotationMatrix[1];
    		m16[2]=m_rotationMatrix[2];
    		m16[4]=m_rotationMatrix[3];
    		m16[5]=m_rotationMatrix[4];
    		m16[6]=m_rotationMatrix[5];
    		m16[8]=m_rotationMatrix[6];
    		m16[9]=m_rotationMatrix[7];
    		m16[10]=m_rotationMatrix[8];
    		float[] m16t = new float[16];
    		Matrix.transposeM(m16t, 0, m16, 0);
    		Matrix.multiplyMV(resp , 0, m16t, 0, t , 0);
    		
    		globalLinnearAcc[0] = resp[0];
    		globalLinnearAcc[1] = resp[1];
    		globalLinnearAcc[2] = resp[2];
    		
    		// set vertical and horizontal Gs
    		float hGs = (float)Math.sqrt(Math.pow(globalLinnearAcc[0], 2) + Math.pow(globalLinnearAcc[1], 2));
    		if(globalLinnearAcc[2] < minVGs)
    			minVGs = globalLinnearAcc[2];
    		if(globalLinnearAcc[2] > maxVGs)
    			maxVGs = globalLinnearAcc[2];
    		if(hGs < minHGs)
    			minHGs = hGs;
    		if(hGs > maxHGs)
    			maxHGs = hGs;
    		verticalGs.setText("maxVGs: "+maxVGs +"  minVGs: "+minVGs);
    		horizontalGs.setText("maxHGs: "+maxHGs +"  minHGs: "+minHGs);
		}
    }

    // vector utils
    private float[] cross(float[] a, float[] b){
    	float[] c = new float[3];
    	
    	c[0] = a[1]*b[2]-a[2]*b[1];
    	c[1] = a[2]*b[0]-a[0]*b[2];
    	c[2] = a[0]*b[1]-a[1]*b[0];
    	
    	return c;
    }
    private double vecLength(float[] v){
    	return Math.sqrt(Math.pow(v[0], 2)+Math.pow(v[1], 2)+Math.pow(v[2], 2));
    }
    
    public void action(View v){
    	Log.d(TAG, "action");
    	minHGs = 0;
     	minVGs = 0;
     	maxHGs = 0;
     	maxVGs = 0;
    	//refreshDisplay();
    }
    private void refreshDisplay(){
    	String v =  m_vals[0]+"    "+m_vals[1]+"    "+m_vals[2]+"\n";
    	v += display.getText();
    	display.setText(v);
    	newDataCkecked();
    }
    
    private void newDataAlarm(){
    	newData = true;
    	actionButton.setBackgroundColor(Color.GREEN);
    }
    private void newDataCkecked(){
    	newData = false;
    	actionButton.setBackgroundColor(Color.LTGRAY);
    }
    
    private void testLocalToGlobal(){
    	float[] m = new float[9];
		float[] gValues = new float[3];
		gValues[0] = 0;
		gValues[1] = 4;
		gValues[2] = 4;
		
		float[] northDir = new float[3];
		northDir[0] = 0;
		northDir[1] = 10;
		northDir[2] = -10;
		
		float[] gValuesClone = gValues.clone();
		float[] northDirClone = northDir.clone();
		
		
		boolean bien = SensorManager.getRotationMatrix(m, null,
				gValuesClone, northDirClone);
		
		float[] resp = new float[4];
		float[] t = {0,0,15,0};
		float[] m16 = new float[16];
		m16[0]=m[0];
		m16[1]=m[1];
		m16[2]=m[2];
		m16[4]=m[3];
		m16[5]=m[4];
		m16[6]=m[5];
		m16[8]=m[6];
		m16[9]=m[7];
		m16[10]=m[8];
		
		float[] m16t = new float[16];
		Matrix.transposeM(m16t, 0, m16, 0);
		
		Matrix.multiplyMV(resp , 0, m16t, 0, t , 0);
		
		Log.d(TAG,">> m: ["+m[0]+"|"+m[1]+"|"+m[2]+"]");
		Log.d(TAG,">> m: ["+m[3]+"|"+m[4]+"|"+m[5]+"]");
		Log.d(TAG,">> m: ["+m[6]+"|"+m[7]+"|"+m[8]+"]");
		
		Log.d(TAG,bien+ ">> resp: ["+resp[0]+"|"+resp[1]+"|"+resp[2]+"]");
    }
}
